diff -Nur --exclude aclocal.m4 --exclude mdt_convert --exclude '*.in' --exclude libs.lib --exclude '*.pyc' --exclude mdt.lib --exclude library_restraints --exclude config.py --exclude top_interpreter modeller-SVN/modlib/modeller/automodel/automodel.py modeller-trunk/modlib/modeller/automodel/automodel.py
--- modeller-SVN/modlib/modeller/automodel/automodel.py	2015-05-28 16:28:09.559840391 -0700
+++ modeller-trunk/modlib/modeller/automodel/automodel.py	2015-05-28 16:46:17.480112250 -0700
@@ -13,23 +13,9 @@
 import generate
 import randomize
 import autosched
-from modeller import forms
 
 __docformat__ = "epytext en"
 
-class trunc_gaussian(forms.restraint_form):
-    """An implementation of my truncated Gaussian restraint (type 50)
-    as a C extension module"""
-
-    import sys
-    sys.path.append('/netapp/sali/allosmod/modeller-SVN')
-    import _cuser_form
-    
-    _builtin_index = _cuser_form.myform_create()
-    
-    def __init__(self, group, feature, mean, stdev):
-        forms.restraint_form.__init__(self, group, feature, 0, (mean, stdev))
-                        
 class automodel(model):
     """Automatically build complete model(s) using template information"""
 
@@ -42,20 +28,12 @@
     deviation = 4.0
     toplib = '${LIB}/top_heav.lib'
     parlib = '${LIB}/par.lib'
-#    spline_on_site = True
-    spline_on_site = False
+    spline_on_site = True
     initial_malign3d = False
     final_malign3d = False
     starting_model = 1
     ending_model = 1
     write_intermediates = False
-    MDtemp = 300.0
-    tmstep = 4.0
-    incmov = 1000
-    incequil = 1000
-    nmov = 1000
-    cap_atom_shift = 0.39
-    convert_restraints = False
     library_schedule = autosched.normal
     pdb_ext = '.pdb'
     repeat_optimization = 1
@@ -84,9 +62,7 @@
 
     def __init__(self, env, alnfile, knowns, sequence,
                  deviation=None, library_schedule=None, csrfile=None,
-                 inifile=None, assess_methods=None, write_intermediates=None,
-                 MDtemp=None, tmstep=None, incmov=None, incequil=None, nmov=None,
-                 cap_atom_shift=None, convert_restraints=None):
+                 inifile=None, assess_methods=None):
         model.__init__(self, env)
         self.alnfile = alnfile
         if isinstance(knowns, tuple):
@@ -106,23 +82,6 @@
                 env.libs.topology.clear() and env.libs.parameters.clear()""")
         if deviation:
             self.deviation = deviation
-            self.rand_method = randomize.xyz
-        if write_intermediates:
-            self.write_intermediates = write_intermediates
-        if MDtemp:
-            self.MDtemp = MDtemp
-        if tmstep:
-            self.tmstep = tmstep
-        if incmov:
-            self.incmov = incmov
-        if incequil:
-            self.incequil= incequil
-        if nmov:
-            self.nmov = nmov
-        if cap_atom_shift:
-            self.cap_atom_shift = cap_atom_shift
-        if convert_restraints:
-            self.convert_restraints = convert_restraints
         if library_schedule:
             self.library_schedule = library_schedule
         if csrfile:
@@ -144,14 +103,6 @@
         # done when restraints are read for each *.B9999???? model):
         self.rd_restraints()
 
-        # Convert certain restraints read in from rsr file into splines
-        if self.convert_restraints:
-            self.convertcsr()
-            self.restraints.write('converted.rsr') # output spline restraints for testing
-            self.restraints.clear()
-            self.restraints.append(file='converted.rsr')
-            #return # exit, since running without c_extention is >5 times faster
-        
         # getting model(s) (topology library must be in memory; ensured
         # now by one of the three GENERATE_METHOD routines):
         atmsel = self._check_select_atoms()
@@ -168,8 +119,7 @@
         self.csrfile = self.sequence + '.rsr'
         self.schfile = self.sequence + '.sch'
         self.generate_method = generate.transfer_xyz
-        #self.rand_method = randomize.xyz
-        self.rand_method = None
+        self.rand_method = randomize.xyz
         self.md_level = refine.very_fast
 
     def auto_align(self, matrix_file='family.mat', overhang=0, write_fit=False):
@@ -348,7 +298,7 @@
         out = {'name':filename, 'num':num, 'failure':None}
         try:
             for irepeat in range(0, self.repeat_optimization):
-                self.single_model_pass(atmsel, num, sched, irepeat)
+                self.single_model_pass(atmsel, num, sched)
             self.to_iupac()
         except (ModellerError, OverflowError), detail:
             if len(str(detail)) > 0:
@@ -416,16 +366,14 @@
                 if out:
                     out[key] = value
 
-    def single_model_pass(self, atmsel, num, sched, irepeat):
+    def single_model_pass(self, atmsel, num, sched):
         """Perform a single pass of model optimization"""
         actions = self.get_optimize_actions()
         for (numstep, step) in enumerate(sched):
             molpdf = step.optimize(atmsel, output=self.optimize_output,
+                                   max_iterations=self.max_var_iterations,
                                    actions=actions)
-#                                   max_iterations=self.max_var_iterations,
-
-            # write out intermediate files
-            self.write_int(numstep + 1 + len(sched)*irepeat, num)
+            self.write_int(numstep + 1, num)
             # Also check for molpdf being NaN (depends on Python version; on 2.3
             # x86 it evaluates as equal to everything; with 2.4 x86 it is
             # not greater or smaller than anything)
@@ -436,14 +384,13 @@
                           "Obj. func. (%.3f) exceeded max_molpdf (%.3f) " \
                                       % (molpdf, self.max_molpdf))
         actions = self.get_refine_actions()
-        self.refine(atmsel, actions, num, irepeat, self.write_intermediates, self.MDtemp, self.tmstep,
-                    self.incmov, self.incequil, self.nmov, self.cap_atom_shift)
+        self.refine(atmsel, actions)
 
 
     def write_int(self, id1, id2):
         """Write intermediate model file during optimization, if so requested"""
         if self.write_intermediates:
-            self.write(file=self.get_model_filename(self.sequence, id1, id2,
+            self.write(file=get_model_filename(self.sequence, id1, id2,
                                                self.pdb_ext))
 
     def read_alignment(self, aln=None):
@@ -575,52 +522,6 @@
         # changes are reflected in the current restraints:
         self.special_restraints(aln)
 
-    def convertcsr(self):
-        """Convert certain restraints read in from rsr file into spline restraints"""
-        """Right now only convert trunctated Gaussian and multi Gaussian distance restraints"""
-        
-        rsr = self.restraints
-        from modeller import forms, physical, features
-                                
-        rsr.spline(trunc_gaussian, features.distance, physical.ca_distance,
-                   spline_dx=0.05, spline_range=4.0,
-                   spline_min_points=5, edat=None)
-        rsr.spline(trunc_gaussian, features.distance, physical.n_o_distance, 
-                   spline_dx=0.05, spline_range=4.0, 
-                   spline_min_points=5, edat=None)
-        rsr.spline(trunc_gaussian, features.distance, physical.sd_mn_distance,
-                   spline_dx=0.05, spline_range=4.0,
-                   spline_min_points=5, edat=None)
-        rsr.spline(trunc_gaussian, features.distance, physical.sd_sd_distance,
-                   spline_dx=0.05, spline_range=4.0,
-                   spline_min_points=5, edat=None)
-        rsr.spline(trunc_gaussian, features.distance, physical.xy_distance,
-                   spline_dx=0.05, spline_range=4.0,
-                   spline_min_points=5, edat=None)
-        rsr.spline(trunc_gaussian, features.distance, physical.disulfide_distance,
-                   spline_dx=0.05, spline_range=4.0,
-                   spline_min_points=5, edat=None)
-
-        rsr.spline(forms.multi_gaussian, features.distance, physical.ca_distance,
-                   spline_dx=0.05, spline_range=4.0,
-                   spline_min_points=5, edat=None)
-        rsr.spline(forms.multi_gaussian, features.distance, physical.n_o_distance, 
-                   spline_dx=0.05, spline_range=4.0,
-                   spline_min_points=5, edat=None)
-        rsr.spline(forms.multi_gaussian, features.distance, physical.sd_mn_distance,
-                   spline_dx=0.05, spline_range=4.0,
-                   spline_min_points=5, edat=None)
-        rsr.spline(forms.multi_gaussian, features.distance, physical.sd_sd_distance,
-                   spline_dx=0.05, spline_range=4.0,
-                   spline_min_points=5, edat=None)
-        rsr.spline(forms.multi_gaussian, features.distance, physical.xy_distance,
-                   spline_dx=0.05, spline_range=4.0,
-                   spline_min_points=5, edat=None)
-        rsr.spline(forms.multi_gaussian, features.distance, physical.disulfide_distance,
-                   spline_dx=0.05, spline_range=4.0,
-                   spline_min_points=5, edat=None)
-                        
-
     def distance_restraints(self, atmsel, aln):
         """Construct homology-derived distance restraints"""
         rsr = self.restraints
@@ -815,7 +716,7 @@
         self.restraints.unpick_all()
         self.restraints.pick(atmsel)
 
-    def refine(self, atmsel, actions, num, irepeat, write_intermediates, MDtemp, tmstep, incmov, incequil, nmov, cap_atom_shift):
+    def refine(self, atmsel, actions):
         """Refine the optimized model with MD and CG"""
         # Save the current model:
         if self.fit_in_refine != 'NO_FIT':
@@ -826,21 +727,17 @@
             self.initial_refine_hot(atmsel)
 
         # Do simulated annealing MD:
-        edat = energy_data(copy=self.env.edat)
-        #update_dynamic=(contact_shell-max_overlap_dist)/2, max_overlap_dist=3.2
-        edat.contact_shell=4.0
-        edat.update_dynamic=0.39
         if self.md_level:
-            self.md_level(atmsel, actions, num, irepeat, write_intermediates, MDtemp, tmstep, incmov, incequil, nmov, cap_atom_shift, edat)
+            self.md_level(atmsel, actions)
 
         # Possibly skip 'HOT CG' after MD:
         if self.refine_hot_only:
             self.final_refine_hot(atmsel)
 
         # Get a final conjugate gradients refined structure:
-#        cg = conjugate_gradients()
-#        cg.optimize(atmsel, max_iterations=200, output=self.optimize_output,
-#                    actions=actions)
+        cg = conjugate_gradients()
+        cg.optimize(atmsel, max_iterations=200, output=self.optimize_output,
+                    actions=actions)
 
         # Evaluate gross changes between the initial and final refined model:
         if 'NO_FIT' not in self.fit_in_refine:
diff -Nur --exclude aclocal.m4 --exclude mdt_convert --exclude '*.in' --exclude libs.lib --exclude '*.pyc' --exclude mdt.lib --exclude library_restraints --exclude config.py --exclude top_interpreter modeller-SVN/modlib/modeller/automodel/autosched.py modeller-trunk/modlib/modeller/automodel/autosched.py
--- modeller-SVN/modlib/modeller/automodel/autosched.py	2015-05-28 16:28:09.561840408 -0700
+++ modeller-trunk/modlib/modeller/automodel/autosched.py	2015-05-28 16:28:57.857250825 -0700
@@ -10,7 +10,6 @@
 from modeller import physical
 from modeller.schedule import schedule, step
 from modeller.optimizers import conjugate_gradients as CG
-from modeller.optimizers import molecular_dynamics as MD
 
 __docformat__ = "epytext en"
 
@@ -27,40 +26,16 @@
 
 #: thorough optimization
 slow = schedule(4,
-       [ step(CG(max_iterations=500), 2, mk_scale(default=0.00001, nonbond=0.0)) ] + \
-       [ step(CG(max_iterations=500), 9999, mk_scale(default=rng, nonbond=0.0)) for rng in \
-         (0.00001,0.0001,0.001,0.01,0.1) ] + \
-       [ step(CG(max_iterations=500), 9999, mk_scale(default=0.50, nonbond=0.0)),
-         step(CG(max_iterations=500), 9999, mk_scale(default=1.00, nonbond=0.0)),
-         step(CG(max_iterations=500), 9999, mk_scale(default=1.00, nonbond=0.01)),
-         step(CG(max_iterations=500), 9999, mk_scale(default=1.00, nonbond=0.1)),
-         step(CG(max_iterations=500), 9999, mk_scale(default=1.00, nonbond=0.5)),
-         step(CG(max_iterations=500), 9999, physical.values(default=1.00)) ] + \
-       [ step(MD(temperature=rng, cap_atom_shift=0.028, md_time_step=1.0, equilibrate=20, max_iterations=100000), 9999, physical.values(default=1.00)) for rng in \
-         (50.0,100.0,200.0,300.0) ])
-
-# NO CG optimization, just MD equilibration
-#[ step(MD(temperature=0.0001, cap_atom_shift=999.9, md_time_step=0.5, equilibrate=1000, max_iterations=1000), 2, mk_scale(default=0.00001, nonbond=0.0)) ] + \
-#[ step(MD(temperature=0.0001, cap_atom_shift=999.9, md_time_step=0.5, equilibrate=20, max_iterations=1000), 9999, mk_scale(default=rng, nonbond=0.0)) for rng in \
-#  (0.00001,0.0001,0.001,0.01,0.1,0.5) ] + \
-#CG                  
-MDopt = schedule(4,
-       [ step(CG(max_iterations=500), 2, mk_scale(default=0.00001, nonbond=0.0)) ] + \
-       [ step(CG(max_iterations=500), 9999, mk_scale(default=rng, nonbond=0.0)) for rng in \
-                  (0.00001,0.0001,0.001,0.01,0.1,0.5,1.0) ] + \
-       [ step(MD(temperature=rng, cap_atom_shift=0.028, md_time_step=1.0, equilibrate=20, max_iterations=50000), 9999, mk_scale(default=1.00, nonbond=0.001)) for rng in \
-         (50.0,100.0,200.0,300.0) ] + \
-       [ step(MD(temperature=300.0, cap_atom_shift=0.028, md_time_step=1.0, equilibrate=20, max_iterations=50000), 9999, mk_scale(default=1.00, nonbond=0.01)),
-         step(MD(temperature=300.0, cap_atom_shift=0.028, md_time_step=1.0, equilibrate=20, max_iterations=50000), 9999, mk_scale(default=1.00, nonbond=0.1)),
-         step(MD(temperature=300.0, cap_atom_shift=0.028, md_time_step=1.0, equilibrate=20, max_iterations=50000), 9999, mk_scale(default=1.00, nonbond=0.5)),
-         step(MD(temperature=300.0, cap_atom_shift=0.028, md_time_step=1.0, equilibrate=20, max_iterations=50000), 9999, physical.values(default=1.00)) ])
-
-MDnone = schedule(4,
-       [ step(CG(max_iterations=500), 2, mk_scale(default=0.00001, nonbond=0.0)) ])
-
-#: leave unchanged
-none = schedule(0,
-       [ step(MD(temperature=0.01, md_time_step=0.01, equilibrate=1, max_iterations=1), 9999, physical.values(default=1.00)) ])
+       [ step(CG, 2, mk_scale(default=0.01, nonbond=0.0)),
+         step(CG, 4, mk_scale(default=0.10, nonbond=0.0)),
+         step(CG, 6, mk_scale(default=0.50, nonbond=0.0)) ] + \
+       [ step(CG, rng, mk_scale(default=1.00, nonbond=0.0)) for rng in \
+         (8,10,14,18,20,24,30,25,40,45,50,55,60,70,80,90,100,120,140,160,200,
+          250,300,400,500) ] + \
+       [ step(CG, 600, mk_scale(default=1.00, nonbond=0.01)),
+         step(CG, 800, mk_scale(default=1.00, nonbond=0.1)),
+         step(CG, 1000, mk_scale(default=1.00, nonbond=0.5)),
+         step(CG, 9999, physical.values(default=1.00)) ])
 
 #: normal optimization
 normal = schedule(4,
diff -Nur --exclude aclocal.m4 --exclude mdt_convert --exclude '*.in' --exclude libs.lib --exclude '*.pyc' --exclude mdt.lib --exclude library_restraints --exclude config.py --exclude top_interpreter modeller-SVN/modlib/modeller/automodel/loopmodel.py modeller-trunk/modlib/modeller/automodel/loopmodel.py
--- modeller-SVN/modlib/modeller/automodel/loopmodel.py	2015-05-28 16:28:09.573840510 -0700
+++ modeller-trunk/modlib/modeller/automodel/loopmodel.py	2015-05-28 16:46:17.480112250 -0700
@@ -14,7 +14,7 @@
     loop = None
     inimodel = None
     loop_potential = None
-                        
+
     def __init__(self, env, sequence, alnfile=None, knowns=[], inimodel=None,
                  deviation=None, library_schedule=None, csrfile=None,
                  inifile=None, assess_methods=None, loop_assess_methods=None):
@@ -326,9 +326,7 @@
                           output=self.optimize_output, min_atom_shift=0.001,
                           actions=actions)
         if self.loop.md_level:
-            self.loop.md_level(atmsel, actions, num=0, irepeat=0, write_intermediates=False,
-                               MDtemp=300.0, tmstep=4.0, incmov=1000, incequil=1000, nmov=1000,
-                               cap_atom_shift=0.39, edat=energy_data(copy=self.env.edat))
+            self.loop.md_level(atmsel, actions)
         cg = conjugate_gradients()
         cg.optimize(atmsel, max_iterations=1000, output=self.optimize_output,
                     min_atom_shift=0.00001, actions=actions)
diff -Nur --exclude aclocal.m4 --exclude mdt_convert --exclude '*.in' --exclude libs.lib --exclude '*.pyc' --exclude mdt.lib --exclude library_restraints --exclude config.py --exclude top_interpreter modeller-SVN/modlib/modeller/automodel/refine.py modeller-trunk/modlib/modeller/automodel/refine.py
--- modeller-SVN/modlib/modeller/automodel/refine.py	2015-05-28 16:28:09.584840603 -0700
+++ modeller-trunk/modlib/modeller/automodel/refine.py	2015-05-28 16:28:57.855250808 -0700
@@ -3,84 +3,37 @@
    object."""
 
 
-def very_fast(atmsel, actions, num, irepeat, write_intermediates, MDtemp, tmstep, incmov, incequil, nmov, cap_atom_shift, edat):
+def very_fast(atmsel, actions):
     """Very fast MD annealing"""
     # at T=1000, max_atom_shift for 4fs is cca 0.15 A.
-    refine(num, irepeat, write_intermediates, edat, atmsel, actions, cap=cap_atom_shift, timestep=4.0,
+    refine(atmsel, actions, cap=0.39, timestep=4.0,
            equil_its=50, equil_equil=10,
            equil_temps=(150.0, 400.0, 1000.0),
            sampl_its=300, sampl_equil=100,
            sampl_temps=(1000.0, 800.0, 500.0, 300.0))
 
-def minimize_loop(atmsel, actions, num, irepeat, write_intermediates, MDtemp, tmstep, incmov, incequil, nmov, cap_atom_shift, edat):
-    """minimize structure using DOPE or other stat. scoring function"""
-    refine(num, irepeat, write_intermediates, edat, atmsel, actions, cap=cap_atom_shift, timestep=4.0,
-           equil_its=10, equil_equil=10,
-           equil_temps=(300.0, 300.0, 300.0),
-           sampl_its=300, sampl_equil=100,
-           sampl_temps=(200.0, 100.0, 50.0, 10.0))
-           
-def none(atmsel, actions, num, irepeat, write_intermediates, MDtemp, tmstep, incmov, incequil, nmov, cap_atom_shift, edat):
-    """NO MD annealing"""
-    refine(num, irepeat, write_intermediates, edat, atmsel, actions, cap=cap_atom_shift, timestep=0.0001,
-           equil_its=2, equil_equil=1,
-           equil_temps=(0.01, 0.01),
-           sampl_its=2, sampl_equil=1,
-           sampl_temps=(0.01, 0.01))
-
-def consttemp(atmsel, actions, num, irepeat, write_intermediates, MDtemp, tmstep, incmov, incequil, nmov, cap_atom_shift, edat):
-    """constant temperature MD"""
-    if MDtemp > 300.0:
-        EQtemp1=300.0+(MDtemp-300.0)/10.0
-        EQtemp2=300.0+(MDtemp-300.0)/6.0
-        EQtemp3=300.0+(MDtemp-300.0)/4.0
-        EQtemp4=300.0+(MDtemp-300.0)/3.0
-        EQtemp5=300.0+(MDtemp-300.0)/2.5
-        EQtemp6=300.0+(MDtemp-300.0)/2.0
-        EQtemp7=300.0+(MDtemp-300.0)/1.5
-        EQtemp8=MDtemp
-        EQtemp9=MDtemp
-        EQtemp10=MDtemp
-        EQits=50000
-    else:
-        EQtemp1=300.0
-        EQtemp2=300.0
-        EQtemp3=300.0
-        EQtemp4=300.0
-        EQtemp5=300.0
-        EQtemp6=300.0
-        EQtemp7=300.0
-        EQtemp8=300.0
-        EQtemp9=300.0
-        EQtemp10=300.0
-        EQits=50000
-                                                                       #change cap
-    refineCT(num, irepeat, write_intermediates, edat, atmsel, actions, cap=cap_atom_shift, timestep=tmstep,
-           equil_its=EQits, equil_equil=20,
-           equil_temps=(EQtemp1, EQtemp2, EQtemp3, EQtemp4, EQtemp5, EQtemp6, EQtemp7, EQtemp8, EQtemp9, EQtemp10),
-           sampl_its=incmov, sampl_equil=incequil,
-           sampl_temp=MDtemp, sampl_nmov=nmov)
 
-def fast(atmsel, actions, num, irepeat, write_intermediates, MDtemp, tmstep, incmov, incequil, nmov, cap_atom_shift, edat):
+def fast(atmsel, actions):
     """Fast MD annealing"""
-    refine(num, irepeat, write_intermediates, edat, atmsel, actions, cap=cap_atom_shift, timestep=4.0,
+    refine(atmsel, actions, cap=0.39, timestep=4.0,
            equil_its=100, equil_equil=20,
            equil_temps=(150.0, 250.0, 500.0, 1000.0),
            sampl_its=400, sampl_equil=100,
            sampl_temps=(1000.0, 800.0, 500.0, 300.0))
 
-def slow(atmsel, actions, num, irepeat, write_intermediates, MDtemp, tmstep, incmov, incequil, nmov, cap_atom_shift, edat):
+
+def slow(atmsel, actions):
     """Slow MD annealing"""
-    refine(num, irepeat, write_intermediates, edat, atmsel, actions, cap=cap_atom_shift, timestep=4.0,
+    refine(atmsel, actions, cap=0.39, timestep=4.0,
            equil_its=200, equil_equil=20,
            equil_temps=(150.0, 250.0, 400.0, 700.0, 1000.0),
            sampl_its=600, sampl_equil=200,
            sampl_temps=(1000.0, 800.0, 600.0, 500.0, 400.0, 300.0))
 
 
-def very_slow(atmsel, actions, num, irepeat, write_intermediates, MDtemp, tmstep, incmov, incequil, nmov, cap_atom_shift, edat):
+def very_slow(atmsel, actions):
     """Very slow MD annealing"""
-    refine(num, irepeat, write_intermediates, edat, atmsel, actions, cap=cap_atom_shift, timestep=4.0,
+    refine(atmsel, actions, cap=0.39, timestep=4.0,
            equil_its=300, equil_equil=20,
            equil_temps=(150.0, 250.0, 400.0, 700.0, 1000.0, 1300.0),
            sampl_its=1000, sampl_equil=200,
@@ -88,73 +41,28 @@
                         320.0, 300.0))
 
 
-def slow_large(atmsel, actions, num, irepeat, write_intermediates, MDtemp, tmstep, incmov, incequil, nmov, cap_atom_shift, edat):
+def slow_large(atmsel, actions):
     """Very slow/large dt MD annealing"""
-    refine(num, irepeat, write_intermediates, edat, atmsel, actions, cap=cap_atom_shift, timestep=10.0,
+    refine(atmsel, actions, cap=0.39, timestep=10.0,
            equil_its=200, equil_equil=20,
            equil_temps=(150.0, 250.0, 400.0, 700.0, 1000.0, 1500.0),
            sampl_its=2000, sampl_equil=200,
            sampl_temps=(1500.0, 1000.0, 800.0, 600.0, 500.0, 400.0, 300.0))
 
 
-def refine(num, irepeat, write_intermediates, edat, atmsel, actions, cap, timestep, equil_its, equil_equil,
+def refine(atmsel, actions, cap, timestep, equil_its, equil_equil,
            equil_temps, sampl_its, sampl_equil, sampl_temps, **args):
     from modeller.optimizers import molecular_dynamics
 
     mdl = atmsel.get_model()
-    #update_dynamic=(contact_shell-max_overlap_dist)/2, max_overlap_dist=3.2
-            
     md = molecular_dynamics(cap_atom_shift=cap, md_time_step=timestep,
                             md_return='FINAL', output=mdl.optimize_output,
-                            actions=actions, edat=edat, **args)
+                            actions=actions, **args)
     init_vel = True
     # First run for equilibration, the second for sampling:
-    ctr=500*(irepeat+1)
-    for temp in equil_temps:
-        md.optimize(atmsel, max_iterations=equil_its, equilibrate=equil_equil,
-                    temperature=temp, init_velocities=init_vel)
-        init_vel=False #turn off for randomized Dynamics
-        if write_intermediates:
-            ctr=ctr+1
-            atmsel.get_model().write_int(ctr, num)
-    ctr=1000*(irepeat+1)
-    for temp in sampl_temps:
-        md.optimize(atmsel, max_iterations=sampl_its, equilibrate=sampl_equil,
-                    temperature=temp, init_velocities=init_vel)
-        if write_intermediates:
-            ctr=ctr+1
-            atmsel.get_model().write_int(ctr, num)
-
-def refineCT(num, irepeat, write_intermediates, edat, atmsel, actions, cap, timestep, equil_its, equil_equil,
-             equil_temps, sampl_its, sampl_equil, sampl_temp, sampl_nmov, **args):
-    from modeller.optimizers import molecular_dynamics
-    
-    mdl = atmsel.get_model()
-    #update_dynamic=(contact_shell-max_overlap_dist)/2, max_overlap_dist=3.2
-    
-    md = molecular_dynamics(cap_atom_shift=cap, md_time_step=timestep,
-                            md_return='FINAL', output=mdl.optimize_output,
-                            actions=actions, edat=edat, **args)
-#    code=pm.pdb
-#    actions=[actions.write_structure(1000, code+'.B%04d0001.pdb', start=2001)]
-    init_vel = True
-    # First run equilibration, reset velocities to equilibrate more quickly
-    ctr=500*(irepeat+1)
-    for temp in equil_temps:
-        md.optimize(atmsel, max_iterations=equil_its, equilibrate=equil_equil,
-                    temperature=temp, init_velocities=init_vel, md_time_step=timestep)
-        init_vel=False #turn off for randomized Dynamics
-        if write_intermediates:
-            ctr=ctr+1
-            atmsel.get_model().write_int(ctr, num)
-
-
-    init_vel=False #turn off for randomized Dynamics
-    #begin sampling
-    ctr=1000*(irepeat+1)
-    for i in range(sampl_nmov):
-        md.optimize(atmsel, max_iterations=sampl_its, equilibrate=sampl_equil,
-                    temperature=sampl_temp, init_velocities=init_vel, md_time_step=3.0)
-        if write_intermediates:
-            ctr=ctr+1
-            atmsel.get_model().write_int(ctr, num)
+    for (its, equil, temps) in ((equil_its, equil_equil, equil_temps),
+                                (sampl_its, sampl_equil, sampl_temps)):
+        for temp in temps:
+            md.optimize(atmsel, max_iterations=its, equilibrate=equil,
+                        temperature=temp, init_velocities=init_vel)
+            init_vel=False
diff -Nur --exclude aclocal.m4 --exclude mdt_convert --exclude '*.in' --exclude libs.lib --exclude '*.pyc' --exclude mdt.lib --exclude library_restraints --exclude config.py --exclude top_interpreter modeller-SVN/modlib/modeller/optimizers/molecular_dynamics.py modeller-trunk/modlib/modeller/optimizers/molecular_dynamics.py
--- modeller-SVN/modlib/modeller/optimizers/molecular_dynamics.py	2015-05-28 16:28:09.709841666 -0700
+++ modeller-trunk/modlib/modeller/optimizers/molecular_dynamics.py	2015-05-28 16:39:22.166556241 -0700
@@ -17,14 +17,14 @@
                  md_time_step=4.0, init_velocities=True, temperature=293.0,
                  md_return='FINAL', equilibrate=999999, guide_factor=0.,
                  guide_time=0., friction=0., residue_span_range=(0, 99999),
-                 max_iterations=1000,**vars):
+                 **vars):
         builtin_optimizer.__init__(self)
         self._modpt = _modeller.mod_md_optimizer_new(self)
         self.__params = {}
         for key in ("output", "cap_atom_shift", "md_time_step",
                     "init_velocities", "temperature", "md_return",
                     "equilibrate", "guide_factor", "guide_time", "friction",
-                    "residue_span_range", "max_iterations"):
+                    "residue_span_range"):
             vars[key] = eval(key)
         self._update_params(self.__params, self.__ok_keys, vars)
 
